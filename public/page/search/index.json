[{"content":"Hugo官网\n运行环境 hugo版本：v0.117.0（扩展版）\ngo：1.21.0\nPowerShell 7（x64）\nWindows10\nHugo是一个使用Go编写的静态站点生成器，即网站构建工具。\n静态的意思是指在内容在网站上呈现之前需要全部编译成HTML文件。而动态的站点生成器是请求哪个页面就编译生成哪个HTML页面。\n在Windows上可以选用包管理器Chocolatey、Scoop、Winget来安装Hugo。\n这里我选择使用winget来安装。\n安装winget：从 Microsoft Store 获取应用程序安装程序。再安装Hugo扩展版。\nwinget install Hugo.Hugo.Extended 1 测试安装成功与否：hugo version。\n使用 Hugo 时通常会使用Git、Go和Dart Sass 。Go环境则是主要用于Hugo的模块功能。Dart Sass 将 Sass 转译为 CSS。\nWindows 10 默认是 Windows PowerShell 是 5.X 版本，在 Win10 V1903 以上版本后，打开 PowerShell 时，会提示 “尝试新的跨平台 PowerShell aka.ms/pscore6 ” 。安装新版PowerShell：\n$ winget search Microsoft.PowerShell Name Id Version Source PowerShell Microsoft.PowerShell 7.3.6.0 winget PowerShell Preview Microsoft.PowerShell.Preview 7.4.0.3 winget $ winget install \u0026ndash;id Microsoft.Powershell \u0026ndash;source winget 初始化 我们在文档下面创建一个名为MyHugoSite的目录结构：\n1 2 3 cd Documents hugo new site MyHugoSite cd MyHugoSite 提示告诉我们有关主题的获取方式、文件的添加和站点的构建。\n将MyHugoSite目录初始化为Git存储库：\n1 2 3 4 git init 添加主题 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 使用git submodule命令添加一个子模块到themes文件夹下，这个主题子模块可以用作参考。当我们需要对其样式或功能做出修改时，可以将其内容部分或文件拷贝到根目录下（MyHugoSite）对应位置。\n启用主题：在hugo.toml中添加一句theme=\u0026lsquo;hugo-theme-stack\u0026rsquo;：\n启动Hugo的开发服务器查看站点：\n1 hugo server 按ctrl+C停止。\n默认不包括草稿内容。\n添加新页面：\n1 hugo new content posts/the-first-post.md 启动服务器，且包含草稿内容：\n1 2 3 hugo server --buildDrafts 或 hugo server -D 1 2 3 修改配置文件 mv hugo.toml hugo.toml.bak cp themes/hugo-theme-stack/exampleSite/config.yaml . 2023/8/26的config.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 baseurl: https://example.com # languageCode: en-us languageCode: zh-cn theme: hugo-theme-stack paginate: 5 title: 影麟 copyright: 影麟 languages: zh-cn: languageName: 中文 # 博客名 title: 影麟 weight: 1 params: description: 影麟的个人博客 # en: # languageName: English # title: Example Site # weight: 2 # params: # description: Example description # ar: # languageName: عربي # languagedirection: rtl # title: موقع تجريبي # weight: 3 # params: # description: وصف تجريبي # Change it to your Disqus shortname before using disqusShortname: hugo-theme-stack # GA Tracking ID googleAnalytics: # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: true permalinks: post: /p/:slug/ page: /:slug/ params: mainSections: - post featuredImageField: image rssFullContent: true favicon: # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) footer: since: 2020 customText: # 日期格式 dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST sidebar: # 头像处的表情 emoji: 🍥 # 简介 subtitle: 学无止境，勇攀高峰！ avatar: enabled: true local: true # 位于assets/img/下的图片，头像 src: img/avatar.png article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 comments: enabled: true provider: disqus disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false # Waline client configuration see: https://waline.js.org/en/reference/component.html waline: serverURL: lang: pageview: emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email - url locale: admin: Admin placeholder: twikoo: envId: region: path: lang: # See https://cactus.chat/docs/reference/web-client/#configuration for description of the various options cactus: defaultHomeserverUrl: \u0026#34;https://matrix.cactus.chat:8448\u0026#34; serverName: \u0026#34;cactus.chat\u0026#34; siteName: \u0026#34;\u0026#34; # You must insert a unique identifier here matching the one you registered (See https://cactus.chat/docs/getting-started/quick-start/#register-your-site) giscus: repo: repoID: category: categoryID: mapping: lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 gitalk: owner: admin: repo: clientID: clientSecret: cusdis: host: id: widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc opengraph: twitter: # Your Twitter username site: # Available values: summary, summary_large_image card: summary_large_image defaultImage: opengraph: enabled: false local: false src: colorScheme: # Display toggle toggle: true # Available values: auto, light, dark default: auto imageProcessing: cover: enabled: true content: enabled: true ### Custom menu ### See https://docs.stack.jimmycai.com/configuration/custom-menu.html ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter menu: main: [] social: - identifier: github name: GitHub url: https://github.com/Shadow-Kylin/Shadow-Kylin.github.io params: icon: brand-github # - identifier: twitter # name: Twitter # url: https://twitter.com # params: # icon: brand-twitter related: includeNewer: true threshold: 60 toLower: false indices: - name: tags weight: 100 - name: categories weight: 200 markup: goldmark: renderer: ## Set to true if you have HTML content inside Markdown unsafe: true tableOfContents: endLevel: 6 ordered: true startLevel: 1 highlight: noClasses: false codeFences: true guessSyntax: true lineNoStart: 1 lineNos: true lineNumbersInTable: true tabWidth: 4 修改内容区\n1 2 3 cp -r ./themes/hugo-theme-stack/exampleSite/content/categories ./content cp -r ./themes/hugo-theme-stack/exampleSite/content/page ./content cp -r ./themes/hugo-theme-stack/exampleSite/content/_index.zh-cn.md ./content 运行 运行 hugo server。\n初始样子\n修改配置和添加文章后的样子\n文章位置 主题默认在主页输出 content/post 目录下的内容，应该在那个目录新建文章。\n左侧菜单项目 主页，关于，归档，搜索，链接等页面在 content/page/ 目录中有对应的目录。\n把对应目录中的 index.md 复制为 index.zh-cn.md, 然后将 index.zh-cn.md 的 front matter 中的 title 修改成对应的中文标题就让侧边栏显示成中文。\n主题中的图标 主题自带一些来自 Tabler Icons的图标，它们放在 themes/hugo-theme-stack/assets/icons/ 目录中。\n如果要使用自定义图标，把它们放在 assets/icons/ 目录。\nfront matter是什么：\n文章封面 在 front matter 中通过 image 属性定义要使用的封面图片。\nimage: hugo-logo-wide.svg\n这个封面图片放在哪儿？\n或者我们封面使用外链也可以。\n导入字体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 themes/hugo-theme-stack/assets/scss/style.scss @import url(\u0026#39;https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css\u0026#39;); @import url(\u0026#39;https://cdn.jsdelivr.net/npm/@fontsource/cascadia-code@4.2.1/index.min.css\u0026#39;); 修改字体 themes/hugo-theme-stack/assets/scss/variables.scss :root { --sys-font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Droid Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;; --zh-font-family: \u0026#34;PingFang SC\u0026#34;, \u0026#34;Hiragino Sans GB\u0026#34;, \u0026#34;Droid Sans Fallback\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;; --base-font-family: \u0026#34;Lato\u0026#34;, var(--sys-font-family), var(--zh-font-family), sans-serif; --code-font-family: Menlo, Monaco, Consolas, \u0026#34;Courier New\u0026#34;, monospace; } 代码折叠\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!-- 折叠代码 --\u0026gt; \u0026lt;details class=\u0026#34;codefold\u0026#34;\u0026gt; \u0026lt;summary class=\u0026#34;codefold__title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;codefold__title-text\u0026#34;\u0026gt; \u0026#34; {{ with .Get 0}}{{.}}{{else}}click to expand{{ end }} \u0026#34; \u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; {{ .Inner }} \u0026lt;/details\u0026gt; \u0026lt;!-- 样式 --\u0026gt; \u0026lt;style\u0026gt; .codefold { margin: 1.5em 0; border: 1px solid #e9edf3; /* overflow: hidden; */ background-color: #f6f8fa; } .codefold__title { padding: 0.5em 1em; cursor: pointer; user-select: none; background-color: #f6f8fa; } .codefold__title-text { flex: 1; font-size: 1.2em; font-weight: 600; color: rgb(215, 178, 130); text-decoration: 2px underline; } .codefold_tip { font-size: 1.2em; font-weight: 600; color: #6280ad; } \u0026lt;/style\u0026gt; \u0026lt;!-- 使用格式 双括号 百分号 codefold 标题 百分号 双括号 代码 双括号 百分号 /codefold 百分号 双括号 --\u0026gt; 友链三栏 在下面文件夹中的custom.scss中添加后面代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact.links { display: grid; grid-template-columns: 1fr 1fr 1fr;//三栏 background: none; box-shadow: none; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 10px; \u0026amp;:nth-child(odd) {//奇数 margin-right: 8px; } } } } 音乐播放器 使用APlayer播放器。\n在partials文件夹下添加music.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- require APlayer --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;!-- require MetingJS --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .aplayer-body { opacity: 0.8; color: #030006; font-weight: 600; box-shadow: 0 2px 10px #5b57ca; border-radius: 20px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), fixed: true,//固定到底部 theme: \u0026#39;#e9e9e9\u0026#39;, audio: [ { name: \u0026#39;歌名\u0026#39;, url: \u0026#39;链接\u0026#39;, artist: \u0026#39;歌手名\u0026#39;, cover: \u0026#34;封面地址\u0026#34; }, ] }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 之后，在footer/custom.html中添加{{partial \u0026ldquo;music\u0026rdquo; .}}。\n文章评论 使用Waline，其教程很完整。\n根据Waline教程从头完成到使用Vercel部署完成。\n最后在config.yaml中的waline的serverURL给上你的Vercel服务器地址。\n以及开启评论\ncomments: enabled: true provider: waline\n快速搭建 上面的操作有些儿繁琐，我们可以使用模板快速搭建：CaiJimmy/hugo-theme-stack-starter。\n成果 影麟\n上面博客里的大部分图片都存在了Github，所以你们可能会获取失败。\n参考文章 墨语-Hugo Stack 主题使用方法 建站技术 | 使用 Hugo+Stack 简单搭建一个博客——失迹の博客 （1）带着Stack主题入坑Hugo\n","date":"2024-10-02T00:00:00Z","image":"https://hugo.opendocs.io/images/hugo-logo-wide.svg","permalink":"http://localhost:1313/actions-test/p/hugostack%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"【Hugo】Stack主题的使用记录"},{"content":"要快速开始一个 Vue.js 项目，可以按照以下步骤进行：\n1. 安装 Node.js 和 npm 首先确保你已经安装了 Node.js。安装 Node.js 后，npm（Node 包管理器）会自动安装。\n在终端中运行以下命令以检查是否安装成功：\n1 2 node -v npm -v 2. 安装 Vue CLI 使用 Vue CLI 可以快速搭建 Vue.js 项目。通过 npm 安装 Vue CLI：\n1 npm install -g @vue/cli 你可以使用以下命令检查 Vue CLI 是否安装成功：\n1 vue --version 3. 创建新的 Vue 项目 使用 Vue CLI 创建一个新的项目。你可以用以下命令：\n1 vue create my-project 在命令中，将 my-project 替换为你的项目名称。接下来，CLI 会提示你选择一些配置选项。你可以选择默认配置，或根据需要自定义配置。\n4. 进入项目目录 创建项目后，进入项目目录：\n1 cd my-project 5. 运行开发服务器 启动 Vue 项目的开发服务器：\n1 npm run serve 然后打开浏览器，访问 http://localhost:8080（默认端口），你就可以看到 Vue.js 应用程序在运行了。\n6. 开始开发 在项目的 src 目录中，你可以找到 App.vue 和 main.js 文件。你可以开始编辑这些文件以添加你的代码和组件。\n7. 添加组件 你可以在 src/components 目录下创建新的组件。例如，创建一个 HelloWorld.vue 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, Vue!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 添加样式 */ \u0026lt;/style\u0026gt; 然后在 App.vue 中引入并使用它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;HelloWorld /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; 8. 安装依赖 如果你需要使用其他库或工具，比如 Vue Router 或 Vuex，可以使用 npm 安装它们。例如，安装 Vue Router：\n1 npm install vue-router 9. 构建生产版本 当你完成开发并准备部署时，可以运行以下命令构建生产版本：\n1 npm run build 构建后的文件会放在 dist 目录中，可以将这个目录中的内容部署到服务器上。\n10. 查看文档和学习资源 Vue.js 官方文档 Vue Router 文档 Vuex 文档 总结 这些步骤可以帮助你快速入门 Vue.js。根据你的项目需求，可以逐步深入学习 Vue 的更多特性和用法。\n","date":"2024-10-02T00:00:00Z","image":"https://avatars.githubusercontent.com/u/102173622?v=4","permalink":"http://localhost:1313/actions-test/p/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/","title":"创建Vue项目"},{"content":"TinyVue 项目概述TinyVue 是一套面向企业级应用的跨端、跨框架 UI 组件库，兼容 Vue 2 和 Vue 3 两个版本，并且同时支持 PC 端和移动端。该项目提供了超过 104 个简洁、易用且功能强大的组件，为开发者提供了丰富的开发资源。更重要的是，它的设计理念是模板、样式、逻辑分离，确保代码的可移植性和灵活性。作为一个开发者，我非常欣赏 TinyVue 这种一次开发，多端兼容的设计理念，因为这不仅减少了项目中重复造轮子的时间，还能让我们的代码在不同平台之间无缝迁移。项目的独特亮点1. 跨端、跨框架支持在现代的前端开发中，跨端适配是一项巨大的挑战，而 TinyVue 优雅地解决了这个问题。它不仅能够兼容 Vue 2 和 Vue 3，还支持 PC 端和移动端，这意味着无论你是构建桌面应用，还是面向移动用户的 Web 应用，都能轻松使用 TinyVue 组件，真正实现“一套代码，多个平台”。2. 104 个强大组件TinyVue 提供了超过 100 个组件，包括按钮、表单、表格、弹窗等常用组件，此外还有一些更加复杂的图表、树形控件等企业级应用中必不可少的组件。所有的组件都是基于 Vue 的特性精心设计的，既简单易用，又功能强大，能够帮助开发者快速构建复杂的 UI 界面。3. 支持低代码开发随着低代码平台的崛起，很多企业和开发团队开始寻求更加简单、直观的开发方式。TinyVue 为此提供了支持配置式开发的组件，这使得它能够无缝集成到低代码平台中，通过可视化配置实现组件的灵活开发。4. 国际化支持如今，越来越多的企业项目面向全球市场，国际化支持成为不可或缺的一部分。TinyVue 内置了国际化支持，开发者可以轻松地为项目添加多语言支持，快速响应不同语言和地区用户的需求。5. 主题定制TinyVue 提供了主题定制功能，允许开发者根据需求自定义组件的外观和风格。通过简单的配置，你就可以为不同的项目提供符合品牌或设计规范的 UI 风格，大大提升了组件库的适用性。6. 高性能与轻量化在大多数企业级应用中，性能问题是不得不考虑的重要因素。TinyVue 组件库在性能上做了充分的优化，所有组件都是轻量化设计，尽可能减少引入不必要的资源，确保项目在各种设备上都能流畅运行。如何在项目中使用 TinyVue？如果你已经被 TinyVue 的特性所吸引，想要在项目中使用它，这里有一个简单的使用指南，让你可以快速上手。1. 安装 TinyVueTinyVue 提供了针对 Vue 2 和 Vue 3 两个版本的支持。你可以根据你当前的 Vue 项目选择合适的版本进行安装。如果你使用的是 Vue 3：npm i @opentiny/vue@3如果你使用的是 Vue 2：npm i @opentiny/vue@22. 引入并使用组件在安装完成之后，你就可以在项目中引入并使用 TinyVue 提供的组件了。以下是一个简单的使用示例：\u0026lt;script lang=\u0026ldquo;ts\u0026rdquo; setup\u0026gt; import { Button as TinyButton } from \u0026lsquo;@opentiny/vue\u0026rsquo; 点击我 以上代码展示了如何在 Vue 项目中引入 TinyVue 的 Button 组件，并将其用于页面中。你只需引入对应组件，即可在页面中轻松使用 TinyVue 提供的丰富组件库。3. 本地开发与调试如果你想进一步定制 TinyVue 组件，或为其贡献代码，你可以按照以下步骤在本地克隆项目并进行开发：git clone git@github.com:opentiny/tiny-vue.git cd tiny-vue pnpm i启动 Vue 3 项目：pnpm dev启动 Vue 2 项目：pnpm dev2打开浏览器访问：http://127.0.0.1:7130/，你就可以查看并调试 TinyVue 组件了。组件截图结语TinyVue 是一个为现代企业级应用而生的 UI 组件库，它的跨端、跨框架特性，以及丰富的组件和灵活的配置选项，能为开发者提供极大的便利。如果你正面临如何选择一款高效的 UI 组件库的难题，TinyVue 无疑是一个值得考虑的强大工具。文档地址https://opentiny.design/tiny-vue/zh-CN/smb-theme/overview仓库地址https://gitee.com/opentiny/tiny-vue","date":"2024-10-22T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/tinyvue/","title":"TinyVue"},{"content":"以下是 Docker 的一些基础操作总结，涵盖安装、镜像、容器、网络、数据管理等常见任务。\nDocker 基础操作 1. 安装 Docker Docker 官方安装指南 提供了各操作系统（Windows、macOS、Linux）的详细步骤。 Linux（Ubuntu）安装示例： 1 2 3 4 5 6 7 sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; sudo apt-get update sudo apt-get install docker-ce sudo systemctl status docker # 检查 Docker 是否安装成功 2. 镜像操作 搜索镜像：\n1 docker search \u0026lt;镜像名\u0026gt; 示例：docker search ubuntu\n下载镜像：\n1 docker pull \u0026lt;镜像名\u0026gt;:\u0026lt;标签\u0026gt; 示例：docker pull ubuntu:latest\n查看本地镜像：\n1 docker images 删除镜像：\n1 docker rmi \u0026lt;镜像ID\u0026gt; 3. 容器操作 运行容器：\n1 docker run -d -p \u0026lt;宿主端口\u0026gt;:\u0026lt;容器端口\u0026gt; \u0026lt;镜像名\u0026gt; 示例：docker run -d -p 8080:80 nginx 在后台运行一个 Nginx 容器，监听宿主机的 8080 端口。\n查看运行中的容器：\n1 docker ps 查看所有容器（包括已停止的）：\n1 docker ps -a 停止容器：\n1 docker stop \u0026lt;容器ID\u0026gt; 启动容器：\n1 docker start \u0026lt;容器ID\u0026gt; 删除容器：\n1 docker rm \u0026lt;容器ID\u0026gt; 进入正在运行的容器：\n1 docker exec -it \u0026lt;容器ID\u0026gt; /bin/bash 示例：docker exec -it my_container /bin/bash 进入容器的交互式 shell。\n查看容器日志：\n1 docker logs \u0026lt;容器ID\u0026gt; 查看容器详细信息：\n1 docker inspect \u0026lt;容器ID\u0026gt; 4. 容器网络 查看网络：\n1 docker network ls 创建自定义网络：\n1 docker network create \u0026lt;网络名\u0026gt; 示例：docker network create mynetwork\n运行容器并连接到网络：\n1 docker run -d --network \u0026lt;网络名\u0026gt; \u0026lt;镜像名\u0026gt; 示例：docker run -d --network mynetwork nginx\n5. 数据管理（挂载卷） 挂载数据卷：\n1 docker run -v \u0026lt;宿主目录\u0026gt;:\u0026lt;容器目录\u0026gt; \u0026lt;镜像名\u0026gt; 示例：docker run -d -v /mydata:/data nginx 将宿主机的 /mydata 目录挂载到容器的 /data 目录。\n查看所有卷：\n1 docker volume ls 删除卷：\n1 docker volume rm \u0026lt;卷名\u0026gt; 6. Dockerfile 构建镜像 编写 Dockerfile： 创建一个名为 Dockerfile 的文件，并添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 # 使用基础镜像 FROM ubuntu:latest # 安装一些软件 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y vim # 复制文件到容器 COPY ./myfile.txt /usr/src/myfile.txt # 运行时命令 CMD [\u0026#34;echo\u0026#34;, \u0026#34;Hello World!\u0026#34;] 构建镜像：\n1 docker build -t my-custom-image . 查看构建的镜像：\n1 docker images 7. Docker 容器导入/导出 保存容器为镜像：\n1 docker commit \u0026lt;容器ID\u0026gt; \u0026lt;镜像名\u0026gt; 导出容器：\n1 docker export \u0026lt;容器ID\u0026gt; \u0026gt; container.tar 导入容器：\n1 docker import \u0026lt; container.tar 8. 常见问题与调试 查看容器 CPU 和内存使用情况：\n1 docker stats 强制停止所有容器：\n1 docker stop $(docker ps -q) 删除所有已停止的容器：\n1 docker rm $(docker ps -a -q) 通过这些基础操作，你可以方便地进行 Docker 容器的创建、运行、管理和调试。根据实际情况，可以进一步探索 Docker Compose、Kubernetes 等工具，来实现更复杂的应用部署和管理。\n","date":"2024-10-20T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/%E5%85%B3%E4%BA%8Edocker/","title":"关于Docker"},{"content":"关于Docker的第二篇文章 ","date":"2024-10-20T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/%E5%85%B3%E4%BA%8Edocker2/","title":"关于Docker2"},{"content":"关于数据分析-散点图 散点图 什么是散点图？ 散点图显示两个连续型变量之间的关系。\n如何使用散点图？ 散点图用于显示关系。对于相关性，散点图有助于显示两个变量之间线性关系的强度。对于回归，散点图常常会添加拟合线。在质量控制中，散点图常常可以包含规格限或参考线。\n散点图显示关系 散点图将一个变量放在 x 轴上，将另一个变量放在 y 轴上，以此来显示两个连续型变量如何相关。\n回归的散点图在 y 轴上包含响应变量，在 x 轴上包含输入变量。\n散点图示例 示例 1：递增关系 图 1 中的散点图显示了递增关系。x 轴显示公司的员工人数，y 轴显示公司的利润。该散点图显示，随着员工人数的增加，利润也会增加。员工人数较少的公司（在图形左侧）利润较低，员工人数较多的公司利润较高。这是一个非常简单的示例，因为有许多变量会影响公司的利润。 Profits vs Employee Scatterplot 图 1：显示递增关系的散点图 示例 2：递减关系 图 2 中的散点图显示了递减关系。x 轴显示某加工肉的含钠克数；y 轴显示每千克蛋白质的成本。该散点图揭示，随着钠含量的增加，蛋白质成本会下降。钠含量较低的肉（图形左侧）蛋白质成本较高，而钠含量较高的肉蛋白质成本较低。这是有依据的，因为可以向低质量（因而成本较低）的肉中添加盐来改善其味道，这会增加钠含量。 Cost per Kilo Protein Scatterplot 图 2：显示变量之间递减关系的散点图 示例 3：不相关 图 3 中的散点图显示两个变量之间没有关系。x 轴显示预洗牛仔布纤维的载荷大小；y 轴显示测量的线磨损情况。该散点图显示了随机点云图。虽然有人可能会看到，随着载荷大小向右沿着图形增加，线磨损情况略有减少，我们可以使用简单线性回归来验证这种想法。 Thread Wear Scatterplot 图 3：表明变量之间没有关系的散点图 示例 4：曲线关系 图 4 中的散点图显示了两个变量之间的曲线关系。x 轴显示一组国家/地区的人口出生率；y 轴显示人口死亡率。散点图显示，在出生率达到 25 至 30 之前，两个变量呈递减关系。在达到这个点之后，变为递增关系。 Birth and Death Rates Scatterplot 图 4：显示变量之间曲线关系的散点图，从递减变为递增 示例 5：散点图中的离群值 数据中的异常点（即离群值）在散点图中往往非常突出。\n图 5 显示了含有离群值的散点图，图 6 显示了相同数据不含离群值的散点图。位于右上角的单个离群值会影响数据在散点图中的可视化。当散点图中包含异常数据点时，您可以调查数据，以找出出现离群值的原因。您可以显示包含离群值和不含离群值的数据。 Scatter Plot with Outlier 图 5：包含离群值的散点图 Scatter Plot No Outlier 图 6：不含离群值的散点图 定制散点图 可以使用颜色和标记向散点图中添加其他变量的详细信息，以及用于指示规格限等元素的参考线。\n使用颜色和标记 图 7 显示了 116 种轿车型号的重量与马力的散点图。 Weight vs Horsepower Scatterplot 图 7：显示轿车的马力与其重量之间递增关系的散点图 从这个简单的图形中，我们看到了递增关系。较重的轿车有较大的马力；较轻的轿车有较小的马力。\n轿车的原产国被指定为美国、日本或其他国家/地区，轿车的类型被指定为运动型、紧凑型、小型、中型或大型。对这两个变量使用颜色和标记可以增强基本散点图。\n图 8 中的散点图使用颜色来区分代表原产国的 3 个值的数据点。 Weight vs Horsepower with Legend 图 8：与图 7 的散点图相同，按国家着色来显示数值中的差异 我们可以很清晰地看到，马力大于225的轿车产自日本或美国。马力最小的轿车中不包含产自美国的任何轿车。\n还可以为不同类型的轿车添加不同的标记。 Weight vs Horsepower with legend 图 9：与图 7散点图相同，现在已按国家着色，并针对每种类型的轿车使用定制化标记 马力大于或等于 200 的轿车要么是中型车，要么是运动型，以正方形和圆形来显示。马力最小的轿车都是小型轿车，用上三角形来显示。所有轿车中最重的一辆是美国制造的大型轿车，以图表最上方的绿色菱形来表示，但这辆轿车的马力一般。\n您可以利用您的数据探索更多，使用颜色、标记，或者同时使用两者，向散点图中添加维度的考量。\n添加参考线 向散点图中添加参考线很有用。假设我们需要知道哪些轿车不能驶过限重 4,000 磅的老旧木桥。图 10 中的散点图现在有一条参考线，以及说明其相关性的注解。 Weight vs Horsepower with Bar 图 10：与图 9 相同的散点图，但是在重量变量上添加了参考线来代表 4000 磅的上限 图 11 显示了相同的散点图，但是对不能驶过老旧木桥的 4 种轿车添加了标签。 Weight vs Horsepower Scatterplot with Upper Limit 图 11：与图 10 相同的散点图，但是在不符合重量上限的 4 个点上添加了标签 添加规格限 很多情况下，变量都设有规格限。使用图 2 中“肉”的数据，学校食堂采购人员被规定所采购的肉需要至少含有 300 克钠、最好含有 450 克钠、最多含有 600 克钠。图 12 显示了这些规格限相关的散点图。 Protein vs Sodium Scatterplot 图 12：显示了规格限的散点图 添加了这些线条后，很容易就可以看出，4 种类型的加工肉不能为食堂所采购。如图 13 中所示，可以为这些点添加标签和颜色，以提供更多的详细信息。采购人员可以分享这个图形来说明为何不能选购某些肉。 Protein vs Sodium Scatterplot with Limits 图 13：与图 12 相同的散点图，但是为规格限之外的点添加了标签 散点图矩阵 散点图矩阵可以显示多个变量如何相关。绘制了变量所有双向组合后，该矩阵可以显示变量之间的关系，以突出显示哪些可能是重要的关系。此矩阵还能识别多个散点图中的离群值。\n图 14 显示了不同轿车型号数据的散点图矩阵。该散点图使用了与图 9-11 相同的颜色和标记。最左侧那一列中的第 1 个散点图显示了“重量”与“转弯半径”之间的关系。矩阵的上三角形和下三角形互为镜像。 Scatterplot Matrix 图 14：含有个性化颜色和标记的散点图矩阵 该矩阵显示，变量的所有双向组合都有递增关系。\n您可以使用 JMP 向散点图矩阵中添加更多的信息，包括沿着对角线为每个变量添加直方图。还可以将上三角形中的散点图替换为每对变量之间的相关性。图 15 中的散点图矩阵显示了这些定制信息。右侧的图例有一个相关性热图，深红色表示变量的相互组合之间存在强烈的正相关关系。 Scatterplot Matrix with Legend 图 15：显示直方图以及变量之间相关性的散点图矩阵 该矩阵还显示了代表“位移”的直方图中可能的离群值。 我们甚至可以使用 JMP 向矩阵中添加更多的信息，例如，为每个散点图添加密度椭圆，以便查看多个维度中的离群值。图 16 显示了在一个散点图中选中离群值会如何在其他散点图中突出显示该值。 含有突出显示离群值的散点图矩阵 图 16：选择了“重量与转弯半径”散点图中离群值时的散点图矩阵 图 16 中的散点图矩阵显示了每个独立散点图中的密度椭圆。红色圆圈包含大约 95% 的数据。可以探索圆圈之外的点，看看它们是否为多元离群值。图 16 中，被选中的蓝色圆点代表基于“重量与转弯半径”绘制的散点图中的离群值。这个点也是其他某些散点图中的离群值，但不是所有散点图中的离群值。在“位移与马力”图中，这个点在密度椭圆的中间突出显示。\n取消选择这个点后，所有的点都将以相同的亮度显示，如图 17 中所示。从代表“位移与马力”散点图的密度椭圆中可以看出，可能出现离群值的原因显示在代表“位移”的直方图中。在散点图右侧，有多个点位于椭圆之外。颜色显示所有这些点都来自美国制造的轿车，而标记则显示轿车是运动型、中型或大型。对颜色和标记加以说明的注解可以进一步增强散点图矩阵的功能。\n含有离群值的散点图矩阵 图 17：显示“位移与马力”散点图中有趣的离群值的散点图矩阵 您可以利用您的数据，使用散点图矩阵来同时探索多个变量。 散点图和数据类型 连续型数据：适合使用散点图 散点图对连续型数据很适合，因为这些数据是在具有许多可能值的尺度上进行衡量的。以下是连续型数据的一些示例：\n寿命 血压 权重 温度 速度\n分类型或名义型数据：使用条形图 对于分类型或名义型数据，散点图不是最佳选择，因为这些数据是在具有特定值的尺度上进行衡量的。请改用条形图。\n对于分类型数据，样本会分成多个组，并且响应可能有定义好的顺序。例如，在一项调查中，要求您从“强烈不同意”到“强烈同意”这样的范围来提供意见，您的响应就是分类型的。\n对于名义型数据，样本也分成多个组，但没有任何特定的顺序。例如，居住的国家/地区就是名义型变量。您可以使用国家/地区缩写，也可以使用数字对国家/地区名称编码。无论采用哪一种方式，您都只是在为不同的数据组命名而已。\n您可以使用类别型或名义型变量来定制散点图。您可以将不同的颜色或标记分配给这些变量的各个水平。\nhttps://www.jmp.com/zh_cn/statistics-knowledge-portal/exploratory-data-analysis/scatter-plot.html\n","date":"2024-10-20T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","title":"关于数据分析"},{"content":"uniapp中使用u-swipe-action 在开发移动端应用时我们通常需要对单元格进行左划编辑，或者删除操作，此时就可以使用u-swiper-action组件\n基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;up-swipe-action\u0026gt; \u0026lt;up-swipe-action-item v-model:show=\u0026#34;show\u0026#34; :options=\u0026#34;options1\u0026#34; \u0026gt; \u0026lt;view class=\u0026#34;swipe-action up-border-top up-border-bottom\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;swipe-action__content\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;swipe-action__content__text\u0026#34;\u0026gt;基础使用\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/up-swipe-action-item\u0026gt; \u0026lt;/up-swipe-action\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { options1: [{ text: \u0026#39;删除\u0026#39; }] }; }, }; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; .u-page { padding: 0; } .u-demo-block__title { padding: 10px 0 2px 15px; } .swipe-action { \u0026amp;__content { padding: 25rpx 0; \u0026amp;__text { font-size: 15px; color: $up-main-color; padding-left: 30rpx; } } } \u0026lt;/style\u0026gt; 当你需要设置左划后的点击操作可以给 u-swipe-action-item中设置点击事件 @click 就可以设置点击事件了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;up-swipe-action-item v-model:show=\u0026#34;show\u0026#34; :options=\u0026#34;options1\u0026#34; @click = \u0026#34;del()\u0026#34; \u0026gt; \u0026lt;view class=\u0026#34;swipe-action up-border-top up-border-bottom\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;swipe-action__content\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;swipe-action__content__text\u0026#34;\u0026gt;基础使用\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/up-swipe-action-item\u0026gt; \u0026lt;script\u0026gt; export default{ methods:{ del(){ // 这里设置具体的操作 } } } \u0026lt;/script\u0026gt; ","date":"2024-10-19T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/uniapp-%E4%B8%AD%E4%BD%BF%E7%94%A8-u-swipe-action/","title":"uniapp 中使用 u-swipe-action"},{"content":"关于JavaScript的第二篇文章 ","date":"2024-10-19T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/%E5%85%B3%E4%BA%8Ejavascript/","title":"关于javascript"},{"content":"ES6（也叫ECMAScript 2015）及后续版本（ES7、ES8、ES9 等）为 JavaScript 带来了大量的新特性，极大地增强了语言的能力、可读性和开发体验。下面我将详细总结从 ES6 到 最新版本（截至2024年） 的新特性，并对其逐一解释。\n1. ES6 (ECMAScript 2015) 新特性 1.1 let 和 const let：块级作用域变量，声明的变量只在其所在的块内有效。 const：常量，用于声明不会被重新赋值的变量。 示例：\n1 2 let a = 10; const b = 20; 1.2 箭头函数 箭头函数是一种简写函数表达式，并且不会绑定自己的 this， arguments， super 或 new.target，它使用的是父级作用域中的 this 值。 示例：\n1 const add = (x, y) =\u0026gt; x + y; 1.3 模板字面量（Template Literals） 允许使用反引号（`）来定义多行字符串，支持嵌入变量和表达式。 示例：\n1 2 const name = \u0026#39;John\u0026#39;; console.log(`Hello, ${name}!`); // 输出: Hello, John! 1.4 解构赋值 允许从数组或对象中提取数据，赋值给变量。 示例：\n1 2 let [a, b] = [1, 2]; let {name, age} = {name: \u0026#39;John\u0026#39;, age: 30}; 1.5 扩展运算符和剩余参数（Spread/Rest Operator） 扩展运算符：可以在函数调用时展开数组或对象。 剩余参数：在函数中收集所有其余参数。 示例：\n1 2 3 4 5 6 let arr = [1, 2, 3]; console.log(...arr); // 展开: 1 2 3 function sum(...args) { return args.reduce((a, b) =\u0026gt; a + b, 0); } 1.6 类（Classes） ES6 引入了类的概念，提供了基于 class 关键字的语法糖，简化了原型继承的操作。 示例：\n1 2 3 4 5 6 7 8 9 10 class Person { constructor(name, age) { this.name = name; this.age = age; } greet() { console.log(`Hello, my name is ${this.name}`); } } 1.7 模块（Modules） 使用 import 和 export 关键字来引入和导出模块，支持模块化开发。 示例：\n1 2 3 4 5 // 导出 export const PI = 3.14; // 导入 import { PI } from \u0026#39;./math.js\u0026#39;; 1.8 Promise 引入 Promise 对象，用于处理异步操作，避免回调地狱。 示例：\n1 2 3 4 5 let promise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(\u0026#34;Done\u0026#34;), 1000); }); promise.then(result =\u0026gt; console.log(result)); 1.9 Symbol Symbol 是一种新的原始数据类型，表示独一无二的值，通常用于对象属性的标识符。 示例：\n1 let sym = Symbol(\u0026#34;unique\u0026#34;); 1.10 for\u0026hellip;of 循环 for...of 循环用于遍历可迭代对象（如数组、字符串等）。 示例：\n1 2 3 4 let arr = [1, 2, 3]; for (let val of arr) { console.log(val); } 1.11 Set 和 Map Set：一种新的数据结构，类似数组，但成员值唯一。 Map：键值对集合，类似对象，但键可以是任意数据类型。 示例：\n1 2 let set = new Set([1, 2, 3]); let map = new Map([[\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;]]); 2. ES7 (ECMAScript 2016) 新特性 2.1 指数运算符 引入 ** 作为指数运算符，代替 Math.pow。 示例：\n1 console.log(2 ** 3); // 输出: 8 2.2 Array.prototype.includes includes 方法用于检查数组中是否包含某个值。 示例：\n1 2 let arr = [1, 2, 3]; console.log(arr.includes(2)); // 输出: true 3. ES8 (ECMAScript 2017) 新特性 3.1 异步函数（Async/Await） async/await 是 Promise 的语法糖，使得异步代码可以用同步的方式书写。 示例：\n1 2 3 4 5 async function fetchData() { let response = await fetch(\u0026#39;https://api.example.com/data\u0026#39;); let data = await response.json(); return data; } 3.2 Object.values 和 Object.entries Object.values 返回对象的所有值。 Object.entries 返回对象的键值对数组。 示例：\n1 2 3 let obj = {a: 1, b: 2}; console.log(Object.values(obj)); // 输出: [1, 2] console.log(Object.entries(obj)); // 输出: [[\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2]] 3.3 字符串填充方法 padStart 和 padEnd 方法用于在字符串的开头或结尾填充指定的字符。 示例：\n1 console.log(\u0026#39;5\u0026#39;.padStart(3, \u0026#39;0\u0026#39;)); // 输出: \u0026#34;005\u0026#34; 4. ES9 (ECMAScript 2018) 新特性 4.1 对象扩展运算符 引入对象的扩展运算符，允许浅拷贝对象。 示例：\n1 2 let obj1 = {a: 1, b: 2}; let obj2 = {...obj1, c: 3}; // 输出: {a: 1, b: 2, c: 3} 4.2 异步迭代（for await...of） 允许在异步可迭代对象上使用 for await...of 语法。 示例：\n1 2 3 4 5 async function process(data) { for await (let item of data) { console.log(item); } } 4.3 正则表达式改进 引入了 dotAll 模式 (/s)，使 . 能够匹配包括换行符在内的任何字符。 示例：\n1 2 let regex = /hello.world/s; console.log(regex.test(\u0026#39;hello\\nworld\u0026#39;)); // 输出: true 5. ES10 (ECMAScript 2019) 新特性 5.1 Array.prototype.flat 和 flatMap flat 方法用于将嵌套数组“拉平”。 flatMap 结合了 map 和 flat 的功能。 示例：\n1 2 let arr = [1, [2, [3]]]; console.log(arr.flat(2)); // 输出: [1, 2, 3] 5.2 Object.fromEntries 允许将键值对数组转换为对象。 示例：\n1 2 let entries = [[\u0026#39;a\u0026#39;, 1], [\u0026#39;b\u0026#39;, 2]]; let obj = Object.fromEntries(entries); // 输出: {a: 1, b: 2} 5.3 String.prototype.trimStart 和 trimEnd 用于去除字符串开头或结尾的空白字符。 示例：\n1 2 let str = \u0026#39; Hello \u0026#39;; console.log(str.trimStart()); // 输出: \u0026#39;Hello \u0026#39; 6. ES11 (ECMAScript 2020) 新特性 6.1 可选链（Optional Chaining ?.） 安全地访问嵌套对象的属性，避免抛出 TypeError。 示例：\n1 2 let user = {}; console.log(user?.address?.street); // 输出: undefined 6.2 空值合并运算符（Nullish Coalescing ??） 当左侧操作数为 null 或 undefined 时，返回右侧操作数。 示例：\n1 2 3 4 let val = null ?? \u0026#39;default\u0026#39;; console.log(val); // 输出: \u0026#39;default \u0026#39; 6.3 动态 import 支持动态导入模块，返回 Promise。 示例：\n1 2 3 import(\u0026#39;module\u0026#39;).then(module =\u0026gt; { module.doSomething(); }); 7. ES12 (ECMAScript 2021) 新特性 7.1 String.prototype.replaceAll 替换字符串中的所有匹配项。 示例：\n1 2 let str = \u0026#39;aabbcc\u0026#39;; console.log(str.replaceAll(\u0026#39;b\u0026#39;, \u0026#39;x\u0026#39;)); // 输出: \u0026#39;aaxxcc\u0026#39; 7.2 逻辑赋值运算符 包括 \u0026amp;\u0026amp;=, ||=, 和 ??= 示例：\n1 2 let a = true; a \u0026amp;\u0026amp;= false; // a 变为 false 8. ES13 (ECMAScript 2022) 新特性 8.1 Top-level await 允许在模块的顶层使用 await。 示例：\n1 2 let data = await fetch(\u0026#39;https://api.example.com\u0026#39;); console.log(await data.json()); 8.2 类的静态块 静态块允许在类的静态上下文中执行代码。 示例：\n1 2 3 4 5 class C { static { // 静态初始化代码 } } 9. ES14 (ECMAScript 2023) 新特性 9.1 Array.prototype.findLast 和 findLastIndex 从数组末尾开始查找元素。 示例：\n1 2 let arr = [1, 2, 3, 4]; console.log(arr.findLast(x =\u0026gt; x % 2 === 0)); // 输出: 4 9.2 哈希集合/哈希地图 HashSet 和 HashMap 引入了对哈希表的支持，更快的数据查找和管理操作。 以上是从 ES6 到最新版本（ES14）的重要新特性总结。每个版本都为 JavaScript 增添了功能，提升了语言的性能和开发者的使用体验。\n","date":"2024-10-17T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/es%E6%96%B0%E7%89%B9%E6%80%A7/","title":"ES新特性"},{"content":"引入UView 写在前面: 写这篇文章是因为，个人开发时为了能够兼容多端的UI所以选择了UViewUI，但是在引入项目时出现了很多问题，最后解决，所以写下这篇文章\n1、第一步安装SCSS 1 2 3 4 5 // 安装sass npm i sass -D // 安装sass-loader，注意需要版本10，否则可能会导致vue与sass的兼容问题而报错 npm i sass-loader@10 -D 2、引入uView主JS库 在项目src目录中的main.js中，引入并使用uView的JS库，注意这两行要放在import Vue之后。\n1 2 3 // main.js import uView from \u0026#34;uview-ui\u0026#34;; Vue.use(uView); 3、在引入uView的全局SCSS主题文件 在项目src目录的uni.scss中引入此文件。\n1 2 3 /* uni.scss */ @import \u0026#39;uview-ui/theme.scss\u0026#39;; 4、引入uView基础样式 在App.vue中首行的位置引入，注意给style标签加入lang=\u0026ldquo;scss\u0026quot;属性\n1 2 3 4 5 \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; /* 注意要写在第一行，同时给style标签加入lang=\u0026#34;scss\u0026#34;属性 */ @import \u0026#34;uview-ui/index.scss\u0026#34;; \u0026lt;/style\u0026gt; 5、配置easycom组件模式 此配置需要在项目src目录的pages.json中进行。\n1 2 3 4 5 6 7 8 9 10 11 12 // pages.json { \u0026#34;easycom\u0026#34;: { \u0026#34;^u-(.*)\u0026#34;: \u0026#34;uview-ui/components/u-$1/u-$1.vue\u0026#34; }, // 此为本身已有的内容 \u0026#34;pages\u0026#34;: [ // ...... ] } 6、对uView进行了npm安装 此配置需要在项目src目录的pages.json中进行。\n1 2 3 4 5 6 // 如果您的项目是HX创建的，根目录又没有package.json文件的话，请先执行如下命令： // npm init -y // 安装 npm install uview-ui@2.0.36 总结 根据上面的步骤使用HbuilderX编辑器，应该就可以编译完成，但是可能你会遇到一些问题 在我的成功引入的环境中:\nnodejs version:17 vue version:vue2 如果你使用vue3的话请引入 UView-plus\n你需要注意的是假如编译报错时可能会显示找不到对应的模块此时就需要在page.json,和引入的scss文件路径进行修改， 注意尽量不要自己敲路径，尽量复制路径，因为你永远不知道自己会不会打错路径，另外根据UView官网你可能会看到如果使用HbuilderX编辑器的话不需要安装scss-loader，这是一个坑，不安装的话会报错,另外如果你使用HbuilderX官网的插件导入的话要注意使用vue2版本，但是我并没有使用成功，可能是我的配置还是有问题。\nQ1:使用Mac系统开发时正常引入UView-plus，使用u-form组件会报错显示语法错误，在Windows系统系正常，问题未解决\n","date":"2024-10-16T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/uniapp-%E5%BC%95%E5%85%A5-uviewui/","title":"uniapp 引入 UViewUI"},{"content":"说到 Controller，相信大家都不陌生，它可以很方便地对外提供数据接口。它的定位，我认为是「不可或缺的配角」，说它不可或缺是因为无论是传统的三层架构还是现在的COLA架构，Controller 层依旧有一席之地，说明他的必要性；说它是配角是因为 Controller 层的代码一般是不负责具体的逻辑业务逻辑实现，但是它负责接收和响应请求 从现状看问题 Controller 主要的工作有以下几项\n接收请求并解析参数 调用 Service 执行具体的业务代码（可能包含参数校验） 捕获业务逻辑异常做出反馈 业务逻辑执行成功做出响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //DTO @Data public class TestDTO { private Integer num; private String type; } //Service @Service public class TestService { public Double service(TestDTO testDTO) throws Exception { if (testDTO.getNum() \u0026lt;= 0) { throw new Exception(\u0026#34;输入的数字需要大于0\u0026#34;); } if (testDTO.getType().equals(\u0026#34;square\u0026#34;)) { return Math.pow(testDTO.getNum(), 2); } if (testDTO.getType().equals(\u0026#34;factorial\u0026#34;)) { double result = 1; int num = testDTO.getNum(); while (num \u0026gt; 1) { result = result * num; num -= 1; } return result; } throw new Exception(\u0026#34;未识别的算法\u0026#34;); } } //Controller @RestController public class TestController { private TestService testService; @PostMapping(\u0026#34;/test\u0026#34;) public Double test(@RequestBody TestDTO testDTO) { try { Double result = this.testService.service(testDTO); return result; } catch (Exception e) { throw new RuntimeException(e); } } @Autowired public DTOid setTestService(TestService testService) { this.testService = testService; } } 如果真的按照上面所列的工作项来开发 Controller 代码会有几个问题\n参数校验过多地耦合了业务代码，违背单一职责原则 可能在多个业务中都抛出同一个异常，导致代码重复 各种异常反馈和成功响应格式不统一，接口对接不友好 改造 Controller 层逻辑 统一返回结构 统一返回值类型无论项目前后端是否分离都是非常必要的，方便对接接口的开发人员更加清晰地知道这个接口的调用是否成功（不能仅仅简单地看返回值是否为 null 就判断成功与否，因为有些接口的设计就是如此），使用一个状态码、状态信息就能清楚地了解接口调用情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //定义返回数据结构 public interface IResult { Integer getCode(); String getMessage(); } //常用结果的枚举 public enum ResultEnum implements IResult { SUCCESS(2001, \u0026#34;接口调用成功\u0026#34;), VALIDATE_FAILED(2002, \u0026#34;参数校验失败\u0026#34;), COMMON_FAILED(2003, \u0026#34;接口调用失败\u0026#34;), FORBIDDEN(2004, \u0026#34;没有权限访问资源\u0026#34;); private Integer code; private String message; //省略get、set方法和构造方法 } //统一返回数据结构 @Data @NoArgsConstructor @AllArgsConstructor public class Result\u0026lt;T\u0026gt; { private Integer code; private String message; private T data; public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; success(T data) { return new Result\u0026lt;\u0026gt;(ResultEnum.SUCCESS.getCode(), ResultEnum.SUCCESS.getMessage(), data); } public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; success(String message, T data) { return new Result\u0026lt;\u0026gt;(ResultEnum.SUCCESS.getCode(), message, data); } public static Result\u0026lt;?\u0026gt; failed() { return new Result\u0026lt;\u0026gt;(ResultEnum.COMMON_FAILED.getCode(), ResultEnum.COMMON_FAILED.getMessage(), null); } public static Result\u0026lt;?\u0026gt; failed(String message) { return new Result\u0026lt;\u0026gt;(ResultEnum.COMMON_FAILED.getCode(), message, null); } public static Result\u0026lt;?\u0026gt; failed(IResult errorResult) { return new Result\u0026lt;\u0026gt;(errorResult.getCode(), errorResult.getMessage(), null); } public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; instance(Integer code, String message, T data) { Result\u0026lt;T\u0026gt; result = new Result\u0026lt;\u0026gt;(); result.setCode(code); result.setMessage(message); result.setData(data); return result; } } 统一返回结构后，在 Controller 中就可以使用了，但是每一个 Controller 都写这么一段最终封装的逻辑，这些都是很重复的工作，所以还要继续想办法进一步处理统一返回结构\n统一包装处理 Spring 中提供了一个类 ResponseBodyAdvice ，能帮助我们实现上述需求\nResponseBodyAdvice 是对 Controller 返回的内容在 HttpMessageConverter 进行类型转换之前拦截，进行相应的处理操作后，再将结果返回给客户端。那这样就可以把统一包装的工作放到这个类里面。\n1 2 3 4 5 6 public interface ResponseBodyAdvice\u0026lt;T\u0026gt; { boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType); @Nullable T beforeBodyWrite(@Nullable T body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response); } supports：判断是否要交给 beforeBodyWrite 方法执行，ture：需要；false：不需要 beforeBodyWrite：对 response 进行具体的处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 如果引入了swagger或knife4j的文档生成组件，这里需要仅扫描自己项目的包，否则文档无法正常生成 @RestControllerAdvice(basePackages = \u0026#34;com.example.demo\u0026#34;) public class ResponseAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { @Override public boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType) { // 如果不需要进行封装的，可以添加一些校验手段，比如添加标记排除的注解 return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { // 提供一定的灵活度，如果body已经被包装了，就不进行包装 if (body instanceof Result) { return body; } return Result.success(body); } } 经过这样改造，既能实现对 Controller 返回的数据进行统一包装，又不需要对原有代码进行大量的改动\n处理 cannot be cast to java.lang.String 问题 如果直接使用 ResponseBodyAdvice，对于一般的类型都没有问题，当处理字符串类型时，会抛出 xxx.包装类 cannot be cast to java.lang.String 的类型转换的异常\n在 ResponseBodyAdvice 实现类中 debug 发现，只有 String 类型的 selectedConverterType 参数值是 org.springframework.http.converter.StringHttpMessageConverter，而其他数据类型的值是 org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\nString 类型 图片 其他类型 (如 Integer 类型) 图片 现在问题已经较为清晰了，因为我们需要返回一个 Result 对象\n所以使用 MappingJackson2HttpMessageConverter 是可以正常转换的\n而使用 StringHttpMessageConverter 字符串转换器会导致类型转换失败\n现在处理这个问题有两种方式\n在 beforeBodyWrite 方法处进行判断，如果返回值是 String 类型就对 Result 对象手动进行转换成 JSON 字符串，另外方便前端使用，最好在 @RequestMapping 中指定 ContentType\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @RestControllerAdvice(basePackages = \u0026#34;com.example.demo\u0026#34;) public class ResponseAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { ... @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { // 提供一定的灵活度，如果body已经被包装了，就不进行包装 if (body instanceof Result) { return body; } // 如果返回值是String类型，那就手动把Result对象转换成JSON字符串 if (body instanceof String) { try { return this.objectMapper.writeValueAsString(Result.success(body)); } catch (JsonProcessingException e) { throw new RuntimeException(e); } } return Result.success(body); } ... } @GetMapping(value = \u0026#34;/returnString\u0026#34;, produces = \u0026#34;application/json; charset=UTF-8\u0026#34;) public String returnString() { return \u0026#34;success\u0026#34;; } 修改 HttpMessageConverter 实例集合中 MappingJackson2HttpMessageConverter 的顺序。因为发生上述问题的根源所在是集合中 StringHttpMessageConverter 的顺序先于 MappingJackson2HttpMessageConverter 的，调整顺序后即可从根源上解决这个问题 网上有不少做法是直接在集合中第一位添加 MappingJackson2HttpMessageConverter\n1 2 3 4 5 6 7 8 @Configuration public class WebConfiguration implements WebMvcConfigurer { @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { converters.add(0, new MappingJackson2HttpMessageConverter()); } } 诚然，这种方式可以解决问题，但其实问题的根源不是集合中缺少这一个转换器，而是转换器的顺序导致的，所以最合理的做法应该是调整 MappingJackson2HttpMessageConverter 在集合中的顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class WebMvcConfiguration implements WebMvcConfigurer { /** * 交换MappingJackson2HttpMessageConverter与第一位元素 * 让返回值类型为String的接口能正常返回包装结果 * * @param converters initially an empty list of converters */ @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { for (int i = 0; i \u0026lt; converters.size(); i++) { if (converters.get(i) instanceof MappingJackson2HttpMessageConverter) { MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = (MappingJackson2HttpMessageConverter) converters.get(i); converters.set(i, converters.get(0)); converters.set(0, mappingJackson2HttpMessageConverter); break; } } } } 参数校验 Java API 的规范 JSR303 定义了校验的标准 validation-api ，其中一个比较出名的实现是 hibernate validation ，spring validation 是对其的二次封装，常用于 SpringMVC 的参数自动校验，参数校验的代码就不需要再与业务逻辑代码进行耦合了\n@PathVariable 和 @RequestParam 参数校验 Get 请求的参数接收一般依赖这两个注解，但是处于 url 有长度限制和代码的可维护性，超过 5 个参数尽量用实体来传参\n对 @PathVariable 和 @RequestParam 参数进行校验需要在入参声明约束的注解\n如果校验失败，会抛出 MethodArgumentNotValidException 异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @RestController(value = \u0026#34;prettyTestController\u0026#34;) @RequestMapping(\u0026#34;/pretty\u0026#34;) @Validated public class TestController { private TestService testService; @GetMapping(\u0026#34;/{num}\u0026#34;) public Integer detail(@PathVariable(\u0026#34;num\u0026#34;) @Min(1) @Max(20) Integer num) { return num * num; } @GetMapping(\u0026#34;/getByEmail\u0026#34;) public TestDTO getByAccount(@RequestParam @NotBlank @Email String email) { TestDTO testDTO = new TestDTO(); testDTO.setEmail(email); return testDTO; } @Autowired public void setTestService(TestService prettyTestService) { this.testService = prettyTestService; } } 校验原理 在 SpringMVC 中，有一个类是 RequestResponseBodyMethodProcessor ，这个类有两个作用（实际上可以从名字上得到一点启发）\n用于解析 @RequestBody 标注的参数 处理 @ResponseBody 标注方法的返回值 解析 @RequestBoyd 标注参数的方法是 resolveArgument\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor { /** * Throws MethodArgumentNotValidException if validation fails. * @throws HttpMessageNotReadableException if {@link RequestBody#required()} * is {@code true} and there is no body content or if there is no suitable * converter to read the content with. */ @Override public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception { parameter = parameter.nestedIfOptional(); //把请求数据封装成标注的DTO对象 Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); if (binderFactory != null) { WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) { //执行数据校验 validateIfApplicable(binder, parameter); //如果校验不通过，就抛出MethodArgumentNotValidException异常 //如果我们不自己捕获，那么最终会由DefaultHandlerExceptionResolver捕获处理 if (binder.getBindingResult().hasErrors() \u0026amp;\u0026amp; isBindExceptionRequired(binder, parameter)) { throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); } } if (mavContainer != null) { mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); } } return adaptArgumentIfNecessary(arg, parameter); } } public abstract class AbstractMessageConverterMethodArgumentResolver implements HandlerMethodArgumentResolver { /** * Validate the binding target if applicable. * \u0026lt;p\u0026gt;The default implementation checks for {@code @javax.validation.Valid}, * Spring\u0026#39;s {@link org.springframework.validation.annotation.Validated}, * and custom annotations whose name starts with \u0026#34;Valid\u0026#34;. * @param binder the DataBinder to be used * @param parameter the method parameter descriptor * @since 4.1.5 * @see #isBindExceptionRequired */ protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) { //获取参数上的所有注解 Annotation[] annotations = parameter.getParameterAnnotations(); for (Annotation ann : annotations) { //如果注解中包含了@Valid、@Validated或者是名字以Valid开头的注解就进行参数校验 Object[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann); if (validationHints != null) { //实际校验逻辑，最终会调用Hibernate Validator执行真正的校验 //所以Spring Validation是对Hibernate Validation的二次封装 binder.validate(validationHints); break; } } } } @RequestBody 参数校验 Post、Put 请求的参数推荐使用 @RequestBody 请求体参数\n对 @RequestBody 参数进行校验需要在 DTO 对象中加入校验条件后，再搭配 @Validated 即可完成自动校验\n如果校验失败，会抛出 ConstraintViolationException 异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //DTO @Data public class TestDTO { @NotBlank private String userName; @NotBlank @Length(min = 6, max = 20) private String password; @NotNull @Email private String email; } //Controller @RestController(value = \u0026#34;prettyTestController\u0026#34;) @RequestMapping(\u0026#34;/pretty\u0026#34;) public class TestController { private TestService testService; @PostMapping(\u0026#34;/test-validation\u0026#34;) public void testValidation(@RequestBody @Validated TestDTO testDTO) { this.testService.save(testDTO); } @Autowired public void setTestService(TestService testService) { this.testService = testService; } } 校验原理 声明约束的方式，注解加到了参数上面，可以比较容易猜测到是使用了 AOP 对方法进行增强\n而实际上 Spring 也是通过 MethodValidationPostProcessor 动态注册 AOP 切面，然后使用 MethodValidationInterceptor 对切点方法进行织入增强\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessor implements InitializingBean { //指定了创建切面的Bean的注解 private Class\u0026lt;? extends Annotation\u0026gt; validatedAnnotationType = Validated.class; @Override public void afterPropertiesSet() { //为所有@Validated标注的Bean创建切面 Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true); //创建Advisor进行增强 this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator)); } //创建Advice，本质就是一个方法拦截器 protected Advice createMethodValidationAdvice(@Nullable Validator validator) { return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor()); } } public class MethodValidationInterceptor implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { //无需增强的方法，直接跳过 if (isFactoryBeanMetadataMethod(invocation.getMethod())) { return invocation.proceed(); } Class\u0026lt;?\u0026gt;[] groups = determineValidationGroups(invocation); ExecutableValidator execVal = this.validator.forExecutables(); Method methodToValidate = invocation.getMethod(); Set\u0026lt;ConstraintViolation\u0026lt;Object\u0026gt;\u0026gt; result; try { //方法入参校验，最终还是委托给Hibernate Validator来校验 //所以Spring Validation是对Hibernate Validation的二次封装 result = execVal.validateParameters( invocation.getThis(), methodToValidate, invocation.getArguments(), groups); } catch (IllegalArgumentException ex) { ... } //校验不通过抛出ConstraintViolationException异常 if (!result.isEmpty()) { throw new ConstraintViolationException(result); } //Controller方法调用 Object returnValue = invocation.proceed(); //下面是对返回值做校验，流程和上面大概一样 result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups); if (!result.isEmpty()) { throw new ConstraintViolationException(result); } return returnValue; } } 自定义校验规则 有些时候 JSR303 标准中提供的校验规则不满足复杂的业务需求，也可以自定义校验规则\n自定义校验规则需要做两件事情\n自定义注解类，定义错误信息和一些其他需要的内容 注解校验器，定义判定规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //自定义注解类 @Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented @Constraint(validatedBy = MobileValidator.class) public @interface Mobile { /** * 是否允许为空 */ boolean required() default true; /** * 校验不通过返回的提示信息 */ String message() default \u0026#34;不是一个手机号码格式\u0026#34;; /** * Constraint要求的属性，用于分组校验和扩展，留空就好 */ Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } //注解校验器 public class MobileValidator implements ConstraintValidator\u0026lt;Mobile, CharSequence\u0026gt; { private boolean required = false; private final Pattern pattern = Pattern.compile(\u0026#34;^1[34578][0-9]{9}$\u0026#34;); // 验证手机号 /** * 在验证开始前调用注解里的方法，从而获取到一些注解里的参数 * * @param constraintAnnotation annotation instance for a given constraint declaration */ @Override public void initialize(Mobile constraintAnnotation) { this.required = constraintAnnotation.required(); } /** * 判断参数是否合法 * * @param value object to validate * @param context context in which the constraint is evaluated */ @Override public boolean isValid(CharSequence value, ConstraintValidatorContext context) { if (this.required) { // 验证 return isMobile(value); } if (StringUtils.hasText(value)) { // 验证 return isMobile(value); } return true; } private boolean isMobile(final CharSequence str) { Matcher m = pattern.matcher(str); return m.matches(); } } 自动校验参数真的是一项非常必要、非常有意义的工作。 JSR303 提供了丰富的参数校验规则，再加上复杂业务的自定义校验规则，完全把参数校验和业务逻辑解耦开，代码更加简洁，符合单一职责原则。\n自定义异常与统一拦截异常 原来的代码中可以看到有几个问题\n抛出的异常不够具体，只是简单地把错误信息放到了 Exception 中 抛出异常后，Controller 不能具体地根据异常做出反馈 虽然做了参数自动校验，但是异常返回结构和正常返回结构不一致 自定义异常是为了后面统一拦截异常时，对业务中的异常有更加细颗粒度的区分，拦截时针对不同的异常作出不同的响应\n而统一拦截异常的目的一个是为了可以与前面定义下来的统一包装返回结构能对应上，另一个是我们希望无论系统发生什么异常，Http 的状态码都要是 200 ，尽可能由业务来区分系统的异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 //自定义异常 public class ForbiddenException extends RuntimeException { public ForbiddenException(String message) { super(message); } } //自定义异常 public class BusinessException extends RuntimeException { public BusinessException(String message) { super(message); } } //统一拦截异常 @RestControllerAdvice(basePackages = \u0026#34;com.example.demo\u0026#34;) public class ExceptionAdvice { /** * 捕获 {@code BusinessException} 异常 */ @ExceptionHandler({BusinessException.class}) public Result\u0026lt;?\u0026gt; handleBusinessException(BusinessException ex) { return Result.failed(ex.getMessage()); } /** * 捕获 {@code ForbiddenException} 异常 */ @ExceptionHandler({ForbiddenException.class}) public Result\u0026lt;?\u0026gt; handleForbiddenException(ForbiddenException ex) { return Result.failed(ResultEnum.FORBIDDEN); } /** * {@code @RequestBody} 参数校验不通过时抛出的异常处理 */ @ExceptionHandler({MethodArgumentNotValidException.class}) public Result\u0026lt;?\u0026gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) { BindingResult bindingResult = ex.getBindingResult(); StringBuilder sb = new StringBuilder(\u0026#34;校验失败:\u0026#34;); for (FieldError fieldError : bindingResult.getFieldErrors()) { sb.append(fieldError.getField()).append(\u0026#34;：\u0026#34;).append(fieldError.getDefaultMessage()).append(\u0026#34;, \u0026#34;); } String msg = sb.toString(); if (StringUtils.hasText(msg)) { return Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), msg); } return Result.failed(ResultEnum.VALIDATE_FAILED); } /** * {@code @PathVariable} 和 {@code @RequestParam} 参数校验不通过时抛出的异常处理 */ @ExceptionHandler({ConstraintViolationException.class}) public Result\u0026lt;?\u0026gt; handleConstraintViolationException(ConstraintViolationException ex) { if (StringUtils.hasText(ex.getMessage())) { return Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), ex.getMessage()); } return Result.failed(ResultEnum.VALIDATE_FAILED); } /** * 顶级异常捕获并统一处理，当其他异常无法处理时候选择使用 */ @ExceptionHandler({Exception.class}) public Result\u0026lt;?\u0026gt; handle(Exception ex) { return Result.failed(ex.getMessage()); } } 总结 做好了这一切改动后，可以发现 Controller 的代码变得非常简洁，可以很清楚地知道每一个参数、每一个 DTO 的校验规则，可以很明确地看到每一个 Controller 方法返回的是什么数据，也可以方便每一个异常应该如何进行反馈\n这一套操作下来后，我们能更加专注于业务逻辑的开发，代码简洁、功能完善，何乐而不为呢？\n","date":"2024-10-14T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/contorller%E8%BF%99%E6%A0%B7%E5%86%99/","title":"Contorller这样写"},{"content":"计算机常识 什么是计算机?\n顾名思义，就是能够进行数据运算的机器(台式电脑、笔记本电脑、平板电脑、智能手机)\n计算机_百度百科\n计算机的发明者是谁 ?\n关于电子计算机的发明者是谁这一问题，有好几种答案:\n1936年英国数学家图灵首先提出了一种以程序和输入数据相互作用产生输出的计算机构想，后人将这种机器命名为通用图灵计算机\n1938年克兰德·楚泽发明了首台采用继电器进行工作的计算机,这台计算机命名为Z1，但是继电器是机械式的，并不是完全的电子器材\n1942年阿坦那索夫和贝利发明了首台采用真空管*的计算机，这台计算机命名为ABC\n1946年ENIAC诞生,它拥有了今天计算机的主要结构和功能，是通用计算机\n现在世界上公认的第一台现代电子计算机是1946年在美国宾夕法尼亚大学诞生的ENIAC(Electronic Numerical Integrator And Calculator)\n计算机特点是什么?\n计算机是一种电器, 所以计算机只能识别两种状态, 一种是通电一种是断电\n正是因为如此, 最初ENIAC的程序是由很多开关和连接电线来完成的。但是这样导致改动一次程序要花很长时间(需要人工重新设置很多开关的状态和连接线) 为了提高效率,工程师们想能不能把程序和数据都放在存储器中, 数学家冯·诺依曼将这个思想以数学语言系统阐述，提出了存储程序计算机模型(这是所谓的冯·诺依曼机)\n那利用数学语言如何表示计算机能够识别的通电和断电两种状态呢?\n非常简单用0和1表示即可 所以计算机能识别的所有指令都是由0和1组成的 所以计算机中存储和操作的数据也都是由0和1组成的 0和1更准确的是应该是高电平和低电平, 但是这个不用了解, 只需要知道计算机只能识别0和1以及存储的数据都是由0和1组成的即可。\n","date":"2024-10-10T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"计算机基础知识"},{"content":"流程控制基本概念 默认情况下程序运行后，系统会按书写顺序从上至下依次执行程序中的每一行代码。但是这并不能满足我们所有的开发需求, 为了方便我们控制程序的运行流程，C语言提供3种流程控制结构，不同的流程控制结构可以实现不同的运行流程。 这3种流程结构分别是顺序结构、选择结构、循环结构 顺序结构: 按书写顺序从上至下依次执行 选择结构 对给定的条件进行判断，再根据判断结果来决定执行代码 循环结构 在给定条件成立的情况下，反复执行某一段代码 ","date":"2024-10-10T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"流程控制基本概念"},{"content":"以下是常用的 Git 命令，尤其是在将代码推送到 GitHub 时的常用操作。涵盖了 Git 的基本操作、分支管理、远程仓库操作、合并冲突处理等。\n1. 基础 Git 操作 初始化仓库和克隆仓库 git init\n初始化一个新的 Git 仓库。\ngit clone \u0026lt;repository-url\u0026gt;\n克隆远程仓库到本地。\n查看状态 git status\n查看当前工作区状态（文件是否被修改、是否在暂存区等）。 添加文件到暂存区 git add \u0026lt;file\u0026gt;\n将文件添加到暂存区。\ngit add .\n将所有改动的文件添加到暂存区。\n提交改动 git commit -m \u0026quot;message\u0026quot;\n提交暂存区中的更改到本地仓库，并添加提交信息。\ngit commit --amend\n修改最近一次提交的信息或内容（不建议在已经推送的分支上使用）。\n2. 分支管理 创建和切换分支 git branch \u0026lt;branch-name\u0026gt;\n创建一个新的分支。\ngit checkout \u0026lt;branch-name\u0026gt;\n切换到指定分支。\ngit checkout -b \u0026lt;branch-name\u0026gt;\n创建并切换到一个新分支。\n查看分支 git branch\n列出本地分支。\ngit branch -r\n列出远程分支。\ngit branch -a\n列出所有分支（本地和远程）。\n删除分支 git branch -d \u0026lt;branch-name\u0026gt;\n删除本地分支（分支必须已被合并）。\ngit branch -D \u0026lt;branch-name\u0026gt;\n强制删除本地分支（即使未合并）。\n3. 远程仓库操作 添加远程仓库 git remote add origin \u0026lt;repository-url\u0026gt;\n将远程仓库设置为 origin。 查看远程仓库 git remote -v\n查看当前配置的远程仓库地址。 推送代码到远程仓库 git push origin \u0026lt;branch-name\u0026gt;\n将本地分支推送到远程仓库。\ngit push origin --all\n将所有本地分支推送到远程。\ngit push origin --tags\n推送所有标签到远程仓库。\n拉取远程仓库更新 git pull origin \u0026lt;branch-name\u0026gt;\n从远程仓库拉取最新的更改并与当前分支合并。\ngit fetch origin\n获取远程仓库的最新更改，但不与本地合并。\n4. 合并和冲突处理 合并分支 git merge \u0026lt;branch-name\u0026gt;\n将指定分支合并到当前分支。 解决合并冲突 手动编辑冲突文件后，执行以下命令： git add \u0026lt;conflicted-file\u0026gt;\n标记冲突文件已解决。\ngit commit\n提交合并后的更改。\n放弃合并 git merge --abort\n取消当前的合并操作。 5. 日志与历史记录 查看提交历史 git log\n查看提交历史记录。\ngit log --oneline\n压缩格式显示提交历史（每次提交一行）。\ngit log --graph\n以图形方式显示分支和提交历史。\n查看某个文件的修改历史 git log -p \u0026lt;file\u0026gt;\n查看某个文件的详细修改历史。 6. 撤销操作 撤销修改 git checkout -- \u0026lt;file\u0026gt;\n丢弃某个文件的本地修改，恢复到最近一次提交的状态。 重置暂存区 git reset HEAD \u0026lt;file\u0026gt;\n将文件从暂存区移除，但保留文件的修改。 回滚到某次提交 git reset --hard \u0026lt;commit-hash\u0026gt;\n将仓库回滚到指定的提交，并删除之后的所有更改。\ngit reset --soft \u0026lt;commit-hash\u0026gt;\n回滚到指定的提交，但保留之后的改动，放入暂存区。\n7. 标签管理 创建标签 git tag \u0026lt;tag-name\u0026gt;\n创建一个轻量标签。\ngit tag -a \u0026lt;tag-name\u0026gt; -m \u0026quot;message\u0026quot;\n创建一个带注解的标签。\n查看标签 git tag\n列出所有标签。 推送标签 git push origin \u0026lt;tag-name\u0026gt;\n将某个标签推送到远程仓库。\ngit push origin --tags\n将所有标签推送到远程仓库。\n删除标签 git tag -d \u0026lt;tag-name\u0026gt;\n删除本地标签。\ngit push origin :refs/tags/\u0026lt;tag-name\u0026gt;\n删除远程仓库中的标签。\n8. GitHub 相关命令 Fork 仓库 GitHub 上可以通过点击 Fork 按钮来复制别人的项目到自己的仓库。 克隆 Fork 仓库 git clone https://github.com/\u0026lt;your-username\u0026gt;/\u0026lt;forked-repository\u0026gt;\n将 Fork 的仓库克隆到本地。 拉取原始仓库的更新 git remote add upstream \u0026lt;original-repo-url\u0026gt;\n添加原始仓库为 upstream 远程仓库。\ngit fetch upstream\n拉取原始仓库的更新。\ngit merge upstream/main\n将原始仓库的更改合并到本地。\n创建 Pull Request 通常在 GitHub 界面上点击 New Pull Request 来提交更改请求。 9. Stash (储藏) 储藏未提交的更改 git stash\n储藏当前未提交的更改。\ngit stash list\n查看储藏的更改列表。\ngit stash apply\n应用最近的储藏。\ngit stash pop\n应用最近的储藏并从储藏列表中移除。\n10. 其他有用命令 显示远程仓库 URL git remote show origin\n显示远程仓库详细信息，包括 URL 和当前跟踪的分支。 比较差异 git diff\n显示未暂存的改动。\ngit diff --staged\n显示已暂存但未提交的改动。\n以上命令涵盖了大部分日常开发中与 Git 和 GitHub 相关的操作。希望这些命令能帮助你更好地管理代码和项目。\n","date":"2024-10-04T00:00:00Z","image":"http://localhost:1313/actions-test/p/git-operate/gitlogo_hu300927998262818577.jpeg","permalink":"http://localhost:1313/actions-test/p/git-operate/","title":"Git Operate"},{"content":"TypeScript是什么呢？ TypeScript用来约束js在某些方面太动态了，比如变量没有类型。TS 以JS为基础构建的语言，TS扩展了JavaScript并添加了类型，TS不能被JS解析器直接执行，需要TS-\u0026gt;编译-\u0026gt;JS；\n安装TypeScript 搭建TypeScript开发坏境 下载node.js 安装node.js 使用npm全局安装typescript 进入命令行npm i -g typescript安装成功： image.png 4. 使用TS 新建.ts文件，然后需要编译为.js文件\nimage.png 在文件夹下面多出一个.js文件\nimage.png\nTypeScript语法\n基本类型 对变量或者函数参数以及返回值都可以指定类型，有很多种类型，其中注意any unknown类型的区别，unknown是安全的any类型，不会影响别的变量； P4；\n对象属性指定\n1 2 3 4 5 6 7 /*=========对象属性指定============*/ //对象b必须有name属性 属性后面？表示可选 没有其他没指定的属性 let b:{name:string,age?:number}; //表示对象除了指定的name 还有其他类型的属性都行 let c:{name:string,[propName:string]:any}; c={name:\u0026#39;猪八戒\u0026#39;,age:13}; 2. 函数结构指定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /*==========函数结构指定============*/ //指定函数相关 参数返回参数 即定义函数结构 let d:(a:number,b:number)=\u0026gt;number 3. 数组类型声明 /*=========数组类型声明============*/ //数组 string[]表示字符串数组 let e:string[]; e=[\u0026#39;pink\u0026#39;,\u0026#39;a\u0026#39;]; let g:Array\u0026lt;number\u0026gt;; g=[1,2,3]; 4. 使用元组 /* * 元组,元组就是固定长度的数组 语法：[类型，类型，类型]长度为3 */ let h:[string,string]; h=[\u0026#39;hello\u0026#39;,\u0026#39;world\u0026#39;] 4. enum枚举 /*==============enum枚举==============*/ // 把所有可能情况独列出来 enum Gender{ Male=0, Female=1, } let i:{name:string,gender:Gender}; i={ name:\u0026#39;随悟空\u0026#39;, gender:Gender.Male } 5. \u0026amp; // \u0026amp;表示同时 let j:{name:string}\u0026amp;{age:number}; j={name:\u0026#39;孙悟空\u0026#39;,age:13}; 5. 类型别名 //类型别名 type myType=string; type myType2=1|2|3|4; let k:myType2; let l:myType2; let m:myType; m=\u0026#39;string\u0026#39;; 以上的这些类型多写多用就记住了。\nTypeScript的tsconfig.json配置文件 参考 tsc \u0026ndash;init生成tsconfig.json配置文件，里面的属性分别什么意思使用到的时候自己查询；P9\nTypeSCript的webpack打包使用 首先使用npm init -y初始化项目 下载一些包 npm i -D webpack webpack-cli typescript ts-loader,tsc \u0026ndash;init 然后配置webpack.config.js文件，配置过程中遇到问题，webpack可能版本过高然后导致一些报错，比如在一些新的版本不需要手动设置入口文件，但是我去掉入口文件之后任然报错； 检擦发现文件路径有问题，src webpack.config.js不在part3文件夹下面一定要注意路径的正确性， image.png 框里面的都是同一层的，然后在part3下面npm run build 自动生成html文件插件安装 npm i -D html-webpack-plugin在webpack.config.js中配置plugins\n1 2 3 4 plugins: [ new HTMLWebpackPlugin(), ] 再次运行npm run build可以在dist下面直接生成引用bundle.js的index.html文件，也可以在src下面提供一个index.html模板，在webpack.config.js下面配置;\n1 2 3 new HTMLWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39; }), 还需要下载自动刷新即热更新，安装：npm i -D webpack-dev-server 然后还是要在package.json文件里面配置\n1 \u0026#34;start\u0026#34;: \u0026#34;webpack serve --open\u0026#34; 然后npm start,自动打开index.html文件，更新index.ts文件测试； 安装插件npm i -D clean-webpack-plugin 删除旧的dist目录，同样需要配置：\nplugins: [ new CleanWebpackPlugin(), \u0026hellip; ], 指定哪些文件允许作为模块引入：\nresolve: { extensions: [\u0026rsquo;.ts\u0026rsquo;, \u0026lsquo;.js\u0026rsquo;] } babel使用解决兼容性问题； 安装npm i -D @babel/core @babel/preset-env babel-loader core-js 进行配置：use里面写入，其中corejs是当ie没有promise这种东西的时候corejs把自己实现的代码引入给他使用，usage表示按需引入； //配置babel { //指定加载器 loader: \u0026ldquo;babel-loader\u0026rdquo;, //设置babel //设置预定义的坏境 options: { presets: [ [ //指定坏境插件 \u0026ldquo;@babel/preset-env\u0026rdquo;, //配置信息 { //targets指定兼容的浏览器版本 corejs指定corejs版本在\n//package.json里面看corejs版本 targets: { \u0026ldquo;chrome\u0026rdquo;: \u0026ldquo;58\u0026rdquo;, \u0026ldquo;ie\u0026rdquo;: \u0026ldquo;11\u0026rdquo;, }, \u0026ldquo;corejs\u0026rdquo;: \u0026ldquo;3\u0026rdquo;, \u0026ldquo;useBuiltIns\u0026rdquo;: \u0026ldquo;usage\u0026rdquo; } ] ] } }, \u0026hellip; 面向对象简介 类简介\n面向对象简介 简单说就是程序中所有操作都需要通过操作对象完成：比如 操作浏览器要使用window对象 操作网页要使用document对象 操作控制台要使用console.log对象 tsc -w 实现自动编译\n面向类简介 类\u0026ndash;》对象\u0026mdash;-》模型 总体上这些都是和js一样的，ES6的继承extends super关键字调用父类，抽象类 在前面加关键字：abstract，每个文件使用立即函数，防止变量的冲突，立即函数相当于创建了单独的函数域。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 (function(){ // 禁止一个类被用来创建对象 抽象类是用来继承的 //抽象类中可以添加抽象方法 abstract class Animal{ name:string; constructor(name:string){ this.name=name; } //抽象方法 子类必须重写抽象方法 abstract sayHello():void; } class Dog extends Animal{ sayHello(){ console.log(\u0026#39;汪汪\u0026#39;); } } const dog=new Dog(\u0026#39;旺财\u0026#39;); dog.sayHello(); })(); 禁止类用来创建对象就是用abstract 抽象类，专门用来继承。抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写。\n接口 接口简单理解就是对一些类型的规定，类似于type myType但是又有区别，接口可以重复定义： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 接口定义一个类结构 interface myInterface { name: string; age: number; } // interface可以重复定义 interface myInterface { gender: string; } //接口的使用 const obj: myInterface = { name: \u0026#39;ddd\u0026#39;, age: 222, gender: \u0026#39;man\u0026#39;, } 接口可以定义类的时候限制类的结构 接口中的所有属性都不能有实际值 接口只定义对象的结构 不考虑实际值 比如用接口去实现一个类，其实就是用接口对类做了一些规范\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface myInter { name: string; sayHello():void; } // 定义类时 可以使用类去实现一个接口 实现接口就是使类满足接口的要求 //接口就是对类的限制 class MyClass implements myInter { name: string; constructor(name: string) { this.name = name; } sayHello() { console.log(\u0026#39;Hello~~~\u0026#39;); } } 属性的封装 属性的封装主要是对属性进行私有化，使得外部不能轻易的改变属性值。 通过关键字来定义私有属性 public 修饰的属性可以在任意位置访问 private 私有属性 私有属性只能在当前类内部进行访问 protected 只能在当前类和继承当前类的类中访问 可以通过在类中添加方法使得私有属性被外部访问 js红宝书有讲怎么访问私有属性可以参考 getter方法用来读取属性 setter方法用来设置属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Person { private _name: string; private _age: number; constructor(name: string,age: number){ this._name = name; this._age = age; } // 定义方法用来获取name属性 也可以使用get set 保持属性的使用习惯 getName() { return this._name; } setName(value: string) { this._name = value; } set age(value: number) { this._age = value\u0026gt;0?value: this._age; } } const per = new Person(\u0026#39;孙悟空\u0026#39;,21); console.log(per.getName()); per.setName(\u0026#39;猪八戒\u0026#39;); per.age=12; console.log(per); // 下面的写法等价于上面的this的写法 class C { constructor(public name: string, public age: number){ } } 5. 泛型 当类型不明确的时候可以使用泛型比如： function fn\u0026lt;k\u0026gt;(a:k):k { return a; } 上面里面的k就表示类型，在使用的时候才确定类型， fn(10);//表示泛型为number let result2 = fn\u0026lt;string\u0026gt;(\u0026#39;hello\u0026#39;);//表示指定泛型 为 string \u0026lt;\u0026gt;里面也可以有两个泛型比如： function fn2\u0026lt;T,K\u0026gt;(a:T,b:K):T{ console.log(b); return a; } fn2\u0026lt;number,string\u0026gt;(123,\u0026#39;hello\u0026#39;); 泛型还可以结合接口使用比如： interface Inter { length: number; } //表示泛型T必须是Inter实现类 //1 function fn3\u0026lt;T extends Inter\u0026gt; (a:T) { return a.length; } //2 class MyClass2\u0026lt;T\u0026gt;{ name: T; constructor(name: T){ this.name = name; } } ","date":"2024-10-03T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/typescript%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%B5%81%E7%A8%8B/","title":"TypeScript使用简易流程"},{"content":"记录搭建Hugo 博客，使用stack主题快速启动部署 记录搭建Hugo 博客，使用stack主题快速启动部署\n选择Hugo Hugo 比较偏向后端，编译速度非常快，就这么简单。\n简单记录一下过程 首要任务是选择一个简单好看的主题：hugo-theme-stack\n这个主题最初是在V2EX 看到的，挺小清新的，符合现代审美。然后在Hugo的官方主题商店看到了它。\n看起来主题的亮色模式有点太白了，有些文字看得不是很清楚，后面再想办法调整一下。\n一开始看Hugo官方文档使用命令行新建一个Hugo项目再添加这个主题，因为有一些设置覆盖，一直没弄好，后面参考文档直接使用了这个主题的快速入门模板项目， 直接拉下来，调整配置直接运行起来了，目前使用项目自带的GitHub Action地配置搭配了一个二级域名部署在了GitHub Page上了。\n接下来仔细说说自己做了那些事，改了哪些东西。因为没有参考任何的教程，查找地相关教程都比较笼统，没有针对这个主题的教程，所以下面的内容全都是自己折腾实验的。\n改配置 快速启动模板的GitHub 地址：\nCaiJimmy/hugo-theme-stack-starter\ngit clone https://github.com/CaiJimmy/hugo-theme-stack-starter\n先把代码拉下来，所有的配置文件都在/config/_default 文件夹内，配置文件有很多，自己修改了其中个别几个，下面详细讲讲。\nconfig.toml 博客的基本信息\n标题，用户名，部署的域名，语言\nbaseurl = \u0026ldquo;https://blog.tuwei.space\u0026rdquo; languageCode = \u0026ldquo;zh-Hans\u0026rdquo; paginate = 5 title = \u0026ldquo;koala9527的博客\u0026rdquo;\nDefaultContentLanguage = \u0026ldquo;zh-cn\u0026rdquo;\nhasCJKLanguage = false\nChange it to your Disqus shortname before using disqusShortname = \u0026ldquo;koala9527\u0026rdquo; menu.toml 博客菜单\n删掉了Twitter联系方式，更改GitHub地址，没有什么拿得出手的，就留这个吧。\n[[social]] identifier = \u0026ldquo;github\u0026rdquo; name = \u0026ldquo;GitHub\u0026rdquo; url = \u0026ldquo;https://github.com/koala9527\"\n[social.params] icon = \u0026ldquo;brand-github\u0026rdquo; params.toml 杂项，很多配置，没有仔细研究\n我只改了两项，个性签名和头像。\n[sidebar] emoji = \u0026quot; \u0026quot; subtitle = \u0026ldquo;悟已往者不谏,知来者知可追\u0026rdquo;\n[sidebar.avatar] enabled = true local = true src = \u0026ldquo;img/avatar.jpg\u0026rdquo;\n这里需要注意的是头像的文件位置，需要在项目根目录新建一个assets/img文件夹，把头像的图片文件放进去，官方文档是这么说的：\n部署 先要在GitHub 新建一个公开的项目，我的自己项目地址： koala9527/my-hugo-blog\n此时需要注意推送的分支需要和快速启动模板内.github/deploy.yml文件的CI触发的分支一致。\n我一开始没看见注意使用的是main这个名字，项目中的出发分支名称是master无法触发自动部署。\nimg.png\n接着把本地修改的内容全部提交到刚刚新建的Github仓库，注意分支，Git仓库会触发Github Action自动新建一个gh-page的分支，会自动把content文件夹里面的内容编译到一个public文件夹，一个纯前端文件的项目，这个gh-page分支的内容就是public文件夹的内容。\n目前的项目的目录结构：\n解析域名 点击项目的Settings-\u0026gt;pages\n设置部署构建来源设置成来自分支\n分支名称为gh-pages\n然后再设置一个自定义域名\n设置域名过后需要在域名DNS服务商设置DNS解析。\n上面是是Git账号的域名解析，不确定是不是必须的，在账号设置下的page菜单中添加，添加过后会提示需要一个TXT类型域名解析用来 验证域名的所有权。\n下面是项目的自定义域名解析，是一个二级域名，二级域名记录为blog，解析内容为http://koala9527.github.io ,记录类型为CNAME,koala9527为我自己的Github名称。\n到此为止，整个博客的从零开始到上线部署就完成了。\n写在最后 GitHub的访问貌似有一点慢，后面考虑部署到CDN上面吧，静态页面博客部署，访问，迁移非常地方便快速，这些优点就非常明显！\n","date":"2024-10-02T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/hugo-stack-quick-start/","title":"Hugo Stack Quick Start"},{"content":"这里写关于nodejs的学习\n","date":"2024-10-02T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/nodejs/","title":"NodeJs"},{"content":"这里写关于React的学习\n","date":"2024-10-02T00:00:00Z","image":"http://localhost:1313/actions-test/p/react/react-pic_hu737507177820619659.png","permalink":"http://localhost:1313/actions-test/p/react/","title":"React"},{"content":"这里写关于Spring的学习\n","date":"2024-10-02T00:00:00Z","permalink":"http://localhost:1313/actions-test/p/spring/","title":"Spring"},{"content":"Uniapp 开发篇 目录 介绍 环境搭建（Hello World） 项目基本目录结构 开发规范概述 全局配置文件（pages.json） 创建新页面和页面的配置 配置 tabBar 组件 页面样式与布局 Vue 基本语法复习 Uniapp 的生命周期 下拉刷新 上拉加载 网络请求 一、介绍 Uniapp 是一个基于 Vue.js 开发跨平台应用的框架，支持多个平台（如微信小程序、H5、Android、iOS 等）的开发。它提供了丰富的组件库和 API，开发者只需要编写一套代码，就可以跨平台运行。\nUniapp 的优势 跨平台性：一套代码多端运行 社区支持强大，文档齐全 丰富的插件市场 如果你刚入门小程序开发，可能会对 Uniapp 和原生微信小程序的区别感到困惑。我的建议是先观看以下视频，可以更好地理解两者的优缺点：\n开发微信小程序使用原生开发还是uniapp开发\n二、环境搭建（Hello World） 2.1 下载 HBuilderX HBuilderX 下载地址\nHBuilderX 是官方推荐的 IDE，天然整合了 uniapp，方便高效。\n2.2 下载微信开发者工具 微信开发者工具下载地址\n最终我们需要通过微信开发者工具来打包和预览微信小程序。\n2.3 创建 Uniapp 项目 打开 HBuilderX，点击 新建 -\u0026gt; 项目 -\u0026gt; 选择 Uniapp 模板。 设置项目名称和路径。 生成项目基本结构后，点击运行即可看到 hello world 项目在浏览器中运行。 2.4 在微信开发者工具中运行 在 HBuilderX 中点击运行，选择 运行到小程序模拟器。 如果遇到报错，可以进入微信开发者工具 -\u0026gt; 设置 -\u0026gt; 安全，开启服务端口。 2.5 在手机上运行 连接安卓或 iOS 设备，通过 HBuilderX 将应用运行到真机上。 iOS 设备需要额外的配置，暂不支持直接运行。 三、项目基本目录结构 一个标准的 Uniapp 项目目录结构如下：\n1 2 3 4 5 6 7 8 9 - pages/ # 存放页面文件，Vue 单文件组件 - static/ # 静态资源（图片、字体等） - components/ # 自定义组件 - unpackage/ # 打包后的文件 - App.vue # 根组件 - main.js # 项目入口文件 - manifest.json # 应用配置（名称、版本等） - pages.json # 页面路由、导航栏、TabBar 配置 - uni.scss # 全局样式文件 四、开发规范概述 4.1 命名规范 组件命名：使用驼峰或短横线连接方式，如 myComponent 或 my-component。 CSS 类名：使用短横线连接，如 .my-container。 4.2 文件组织规范 页面文件放在 pages/ 目录下，按功能划分子目录。 组件文件放在 components/ 目录下，按功能划分子目录。 4.3 编码规范 遵循 Vue.js 的编码规范。 使用 Flex 布局确保各平台的一致性。 五、全局配置文件（pages.json） 5.1 globalStyle（全局样式） 用于配置导航栏、标题、窗口背景色等。常见属性如下：\n属性 类型 默认值 说明 navigationBarBackgroundColor HexColor #F8F8F8 导航栏背景颜色 navigationBarTextStyle String black 导航栏标题颜色，支持 black 或 white navigationBarTitleText String 导航栏标题文字内容 注意：页面配置中的样式优先级高于全局配置。\n5.2 pages（页面路由） pages.json 中的 pages 节点定义应用中的页面。配置示例：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;pages\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;style\u0026#34;: { \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;首页\u0026#34; } } ] } 5.3 tabBar（多 Tab 应用） 可以通过 tabBar 配置一级导航栏，示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;tabBar\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#999999\u0026#34;, \u0026#34;selectedColor\u0026#34;: \u0026#34;#3cc51f\u0026#34;, \u0026#34;backgroundColor\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;list\u0026#34;: [ { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/home/home\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;首页\u0026#34;, \u0026#34;iconPath\u0026#34;: \u0026#34;static/icon_home.png\u0026#34;, \u0026#34;selectedIconPath\u0026#34;: \u0026#34;static/icon_home_selected.png\u0026#34; } ] } } 六、创建新页面和页面的配置 6.1 创建新页面 在 HBuilderX 中右键 pages/ 目录，选择 “新建 -\u0026gt; 页面”，为新页面命名。\n6.2 配置 pages.json 手动添加新页面的路径配置：\n1 2 3 4 5 6 { \u0026#34;path\u0026#34;: \u0026#34;pages/newPage/newPage\u0026#34;, \u0026#34;style\u0026#34;: { \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;新页面\u0026#34; } } 6.3 运行新页面 通过浏览器或真机测试，确保新页面正常显示。\n七、配置 tabBar 配置 tabBar 时，可以设置图标、文字以及中间凸起的按钮。以下为基本配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;tabBar\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#999\u0026#34;, \u0026#34;selectedColor\u0026#34;: \u0026#34;#3cc51f\u0026#34;, \u0026#34;backgroundColor\u0026#34;: \u0026#34;#fff\u0026#34;, \u0026#34;list\u0026#34;: [ { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;首页\u0026#34;, \u0026#34;iconPath\u0026#34;: \u0026#34;static/icon_home.png\u0026#34;, \u0026#34;selectedIconPath\u0026#34;: \u0026#34;static/icon_home_selected.png\u0026#34; } ], \u0026#34;midButton\u0026#34;: { \u0026#34;iconPath\u0026#34;: \u0026#34;static/icon_add.png\u0026#34;, \u0026#34;iconWidth\u0026#34;: \u0026#34;50px\u0026#34;, \u0026#34;backgroundImage\u0026#34;: \u0026#34;static/button_bg.png\u0026#34; } } } 八、组件 8.1 Text 组件 用于包裹文本内容，常用属性：\nselectable: 是否可选中内容，默认为 false。 decode: 是否解码 HTML 字符实体，默认为 false。 示例：\n1 \u0026lt;text selectable=\u0026#34;true\u0026#34;\u0026gt;可选中的文本\u0026lt;/text\u0026gt; 8.2 Icon 组件 用于显示图标，常用属性：\ntype: 图标类型，如 success、warn、loading。 size: 图标大小。 color: 图标颜色。 示例：\n1 \u0026lt;icon type=\u0026#34;success\u0026#34; size=\u0026#34;30\u0026#34; color=\u0026#34;#4caf50\u0026#34;\u0026gt;\u0026lt;/icon\u0026gt; 待更新···\n九、页面样式与布局 9.1 尺寸单位 px: 固定像素单位。 rpx: 响应式像素单位，会根据屏幕宽度自动调整。 9.2 样式导入 使用 @import 导入外部样式：\n1 @import \u0026#34;./common.css\u0026#34;; 十、Vue 基本语法复习 Uniapp 是基于 Vue.js 的框架，如果你熟悉 Vue，可以跳过此部分。如果不熟悉，可以复习 Vue 的基本语法。\n十一、Uniapp 的生命周期 应用的生命周期 onLaunch: 应用初始化时触发。 onShow: 应用显示时触发。 onHide: 应用隐藏时触发。 页面生命周期 onLoad: 页面加载时触发。 onShow: 页面显示时触发。 onReady: 页面初次渲染完成时触发。 onHide: 页面隐藏时触发。 onUnload: 页面卸载时触发。 十二、下拉刷新 在 pages.json 中设置 enablePullDownRefresh\n为 true 即可启用下拉刷新：\n1 2 3 4 5 6 { \u0026#34;path\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;style\u0026#34;: { \u0026#34;enablePullDownRefresh\u0026#34;: true } } 十三、上拉加载 在页面的 onReachBottom 函数中处理上拉加载逻辑：\n1 2 3 onReachBottom() { // 加载更多数据 } 十四、网络请求 使用 uni.request 发送网络请求，支持 GET 和 POST 请求。示例：\n1 2 3 4 5 6 7 uni.request({ url: \u0026#39;https://example.com/api\u0026#39;, method: \u0026#39;GET\u0026#39;, success: (res) =\u0026gt; { console.log(res.data); } }); 可以考虑封装网络请求函数，避免重复代码：\n1 2 3 4 5 6 7 8 9 10 11 function request(url, data = {}, method = \u0026#39;GET\u0026#39;) { return new Promise((resolve, reject) =\u0026gt; { uni.request({ url, data, method, success: (res) =\u0026gt; resolve(res.data), fail: (err) =\u0026gt; reject(err) }); }); } 十五、UI组件库的引入 待更新···\n十六、跨平台编译 待更新···\n····内容持续更新\n以上内容是 Uniapp 开发的基础知识。随着项目的复杂度增加，可以深入研究组件通信、状态管理、多端兼容性优化等进阶内容。希望这篇文章对你有帮助！ -by daixun\n","date":"2024-10-02T00:00:00Z","image":"https://qiniu-web-assets.dcloud.net.cn/unidoc/zh/uni-app.png","permalink":"http://localhost:1313/actions-test/p/uniapp-%E5%BC%80%E5%8F%91%E7%AF%87/","title":"Uniapp 开发篇"}]